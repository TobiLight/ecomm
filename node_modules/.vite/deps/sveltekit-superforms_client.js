import {
  parse,
  stringify
} from "./chunk-ILSCI4CI.js";
import {
  derived,
  writable
} from "./chunk-DZ6P7QIQ.js";
import "./chunk-7MMV2AAA.js";
import {
  get_store_value,
  onDestroy,
  tick
} from "./chunk-TP5T5YHH.js";
import "./chunk-X6GHUOVH.js";
import "./chunk-ZC22LKFR.js";

// node_modules/.pnpm/sveltekit-superforms@1.5.0_@sveltejs+kit@1.22.4_svelte@4.1.2_vite@4.4.8_@types+node@18.17.1___svelte@4.1.2_zod@3.21.4/node_modules/sveltekit-superforms/dist/client/index.js
import { beforeNavigate } from "$app/navigation";
import { page as page2 } from "$app/stores";
import { browser as browser2 } from "$app/environment";

// node_modules/.pnpm/sveltekit-superforms@1.5.0_@sveltejs+kit@1.22.4_svelte@4.1.2_vite@4.4.8_@types+node@18.17.1___svelte@4.1.2_zod@3.21.4/node_modules/sveltekit-superforms/dist/stringPath.js
function splitPath(path) {
  return path.toString().split(/[[\].]+/).filter((p) => p);
}
function mergePath(path) {
  return path.reduce((acc, next) => {
    if (typeof next === "number" || !isNaN(parseInt(String(next), 10)))
      acc += `[${String(next)}]`;
    else if (!acc)
      acc += String(next);
    else
      acc += `.${String(next)}`;
    return acc;
  }, "");
}

// node_modules/.pnpm/sveltekit-superforms@1.5.0_@sveltejs+kit@1.22.4_svelte@4.1.2_vite@4.4.8_@types+node@18.17.1___svelte@4.1.2_zod@3.21.4/node_modules/sveltekit-superforms/dist/index.js
var SuperFormError = class _SuperFormError extends Error {
  constructor(message2) {
    super(message2);
    Object.setPrototypeOf(this, _SuperFormError.prototype);
  }
};

// node_modules/.pnpm/sveltekit-superforms@1.5.0_@sveltejs+kit@1.22.4_svelte@4.1.2_vite@4.4.8_@types+node@18.17.1___svelte@4.1.2_zod@3.21.4/node_modules/sveltekit-superforms/dist/traversal.js
function setPath(parent, key, value) {
  parent[key] = value;
  return "skip";
}
function isInvalidPath(originalPath, pathData) {
  return pathData.value !== void 0 && typeof pathData.value !== "object" && pathData.path.length < originalPath.length;
}
function pathExists(obj, path, options = {}) {
  if (!options.modifier) {
    options.modifier = (pathData) => isInvalidPath(path, pathData) ? void 0 : pathData.value;
  }
  const exists = traversePath(obj, path, options.modifier);
  if (!exists)
    return void 0;
  if (options.value === void 0)
    return exists;
  return options.value(exists.value) ? exists : void 0;
}
function traversePath(obj, realPath, modifier) {
  if (!realPath.length)
    return void 0;
  const path = [realPath[0]];
  let parent = obj;
  while (path.length < realPath.length) {
    const key2 = path[path.length - 1];
    const value = modifier ? modifier({
      parent,
      key: String(key2),
      value: parent[key2],
      path: path.map((p) => String(p)),
      isLeaf: false,
      set: (v) => setPath(parent, key2, v)
    }) : parent[key2];
    if (value === void 0)
      return void 0;
    else
      parent = value;
    path.push(realPath[path.length]);
  }
  const key = realPath[realPath.length - 1];
  return {
    parent,
    key: String(key),
    value: parent[key],
    path: realPath.map((p) => String(p)),
    isLeaf: true,
    set: (v) => setPath(parent, key, v)
  };
}
function traversePaths(parent, modifier, path = []) {
  for (const key in parent) {
    const value = parent[key];
    const isLeaf = value === null || typeof value !== "object";
    const pathData = {
      parent,
      key,
      value,
      path: path.map(String).concat([key]),
      isLeaf,
      set: (v) => setPath(parent, key, v)
    };
    const status = modifier(pathData);
    if (status === "abort")
      return status;
    else if (status === "skip")
      continue;
    else if (!isLeaf) {
      const status2 = traversePaths(value, modifier, pathData.path);
      if (status2 === "abort")
        return status2;
    }
  }
}
async function traversePathsAsync(parent, modifier, path = []) {
  for (const key in parent) {
    const value = parent[key];
    const isLeaf = value === null || typeof value !== "object";
    const pathData = {
      parent,
      key,
      value,
      path: path.map(String).concat([key]),
      isLeaf,
      set: (v) => setPath(parent, key, v)
    };
    const status = await modifier(pathData);
    if (status === "abort")
      return status;
    else if (status === "skip")
      break;
    else if (!isLeaf) {
      const status2 = traversePaths(value, modifier, pathData.path);
      if (status2 === "abort")
        return status2;
    }
  }
}
function eqSet(xs, ys) {
  return xs === ys || xs.size === ys.size && [...xs].every((x) => ys.has(x));
}
function comparePaths(newObj, oldObj) {
  const diffPaths = /* @__PURE__ */ new Map();
  function checkPath(data, compareTo) {
    const exists = traversePath(compareTo, data.path);
    function addDiff() {
      diffPaths.set(data.path.join(" "), data.path);
    }
    if (data.isLeaf) {
      if (!exists) {
        addDiff();
      } else if (data.value !== exists.value) {
        addDiff();
      }
    } else if (exists) {
      if (data.value instanceof Date && exists.value instanceof Date && data.value.getTime() != exists.value.getTime()) {
        addDiff();
      } else if (data.value instanceof Set && exists.value instanceof Set && !eqSet(data.value, exists.value)) {
        addDiff();
      }
    }
  }
  traversePaths(newObj, (data) => checkPath(data, oldObj));
  traversePaths(oldObj, (data) => checkPath(data, newObj));
  return Array.from(diffPaths.values());
}
function setPaths(obj, paths, value) {
  for (const path of paths) {
    const leaf = traversePath(obj, path, ({ parent, key, value: value2 }) => {
      if (value2 === void 0 || typeof value2 !== "object") {
        parent[key] = {};
      }
      return parent[key];
    });
    if (leaf)
      leaf.parent[leaf.key] = value;
  }
}

// node_modules/.pnpm/sveltekit-superforms@1.5.0_@sveltejs+kit@1.22.4_svelte@4.1.2_vite@4.4.8_@types+node@18.17.1___svelte@4.1.2_zod@3.21.4/node_modules/sveltekit-superforms/dist/client/proxies.js
var defaultOptions = {
  trueStringValue: "true",
  dateFormat: "iso",
  emptyIfZero: true
};
function booleanProxy(form, path, options = {
  trueStringValue: "true"
}) {
  return _stringProxy(form, path, "boolean", {
    ...defaultOptions,
    ...options
  });
}
function intProxy(form, path, options = {}) {
  return _stringProxy(form, path, "int", {
    ...defaultOptions,
    ...options
  });
}
function numberProxy(form, path, options = {}) {
  return _stringProxy(form, path, "number", {
    ...defaultOptions,
    ...options
  });
}
function dateProxy(form, path, options = {
  format: "iso"
}) {
  return _stringProxy(form, path, "date", {
    ...defaultOptions,
    dateFormat: options.format,
    empty: options.empty
  });
}
function stringProxy(form, path, options) {
  return _stringProxy(form, path, "string", {
    ...defaultOptions,
    empty: options.empty
  });
}
function _stringProxy(form, path, type, options) {
  function toValue(value) {
    if (!value && options.empty !== void 0 && (value !== 0 || options.emptyIfZero)) {
      return options.empty === "null" ? null : void 0;
    }
    if (typeof value === "number") {
      value = value.toString();
    }
    if (typeof value !== "string") {
      throw new SuperFormError("stringProxy received a non-string value.");
    }
    if (type == "string")
      return value;
    else if (type == "boolean")
      return !!value;
    else if (type == "date")
      return new Date(value);
    const numberToConvert = options.delimiter ? value.replace(options.delimiter, ".") : value;
    let num;
    if (type == "number")
      num = parseFloat(numberToConvert);
    else
      num = parseInt(numberToConvert, 10);
    if (options.empty !== void 0 && (num === 0 && options.emptyIfZero || isNaN(num))) {
      return options.empty == "null" ? null : void 0;
    }
    return num;
  }
  const proxy2 = fieldProxy(form, path);
  const proxy = derived(proxy2, (value) => {
    if (value === void 0 || value === null)
      return "";
    if (type == "string") {
      return value;
    } else if (type == "int" || type == "number") {
      const num = value;
      return isNaN(num) ? "" : String(num);
    } else if (type == "date") {
      const date = value;
      if (isNaN(date))
        return "";
      switch (options.dateFormat) {
        case "iso":
          return date.toISOString();
        case "date":
          return date.toISOString().slice(0, 10);
        case "datetime":
          return date.toISOString().slice(0, 16);
        case "time":
          return date.toISOString().slice(11, 16);
        case "date-utc":
          return UTCDate(date);
        case "datetime-utc":
          return UTCDate(date) + "T" + UTCTime(date);
        case "time-utc":
          return UTCTime(date);
        case "date-local":
          return localDate(date);
        case "datetime-local":
          return localDate(date) + "T" + localTime(date);
        case "time-local":
          return localTime(date);
      }
    } else {
      return value ? options.trueStringValue : "";
    }
  });
  return {
    subscribe: proxy.subscribe,
    set(val) {
      proxy2.set(toValue(val));
    },
    update(updater) {
      proxy2.update((f) => toValue(updater(String(f))));
    }
  };
}
function formFieldProxy(form, path) {
  const path2 = splitPath(path);
  const constraintsPath = path2.filter((p) => isNaN(parseInt(String(p)))).join(".");
  return {
    path,
    value: fieldProxy(form.form, path),
    errors: fieldProxy(form.errors, path),
    constraints: fieldProxy(form.constraints, constraintsPath)
  };
}
function fieldProxy(form, path) {
  const path2 = splitPath(path);
  const proxy = derived(form, ($form) => {
    const data = traversePath($form, path2);
    return data == null ? void 0 : data.value;
  });
  return {
    subscribe(...params) {
      const unsub = proxy.subscribe(...params);
      return () => {
        unsub();
      };
    },
    //subscribe: proxy.subscribe,
    update(upd) {
      form.update((f) => {
        const output = traversePath(f, path2);
        if (output)
          output.parent[output.key] = upd(output.value);
        return f;
      });
    },
    set(value) {
      form.update((f) => {
        const output = traversePath(f, path2);
        if (output)
          output.parent[output.key] = value;
        return f;
      });
    }
  };
}
function localDate(date) {
  return date.getFullYear() + "-" + String(date.getMonth() + 1).padStart(2, "0") + "-" + String(date.getDate()).padStart(2, "0");
}
function localTime(date) {
  return String(date.getHours()).padStart(2, "0") + ":" + String(date.getMinutes()).padStart(2, "0");
}
function UTCDate(date) {
  return date.getUTCFullYear() + "-" + String(date.getUTCMonth() + 1).padStart(2, "0") + "-" + String(date.getUTCDate()).padStart(2, "0");
}
function UTCTime(date) {
  return String(date.getUTCHours()).padStart(2, "0") + ":" + String(date.getUTCMinutes()).padStart(2, "0");
}

// node_modules/.pnpm/sveltekit-superforms@1.5.0_@sveltejs+kit@1.22.4_svelte@4.1.2_vite@4.4.8_@types+node@18.17.1___svelte@4.1.2_zod@3.21.4/node_modules/sveltekit-superforms/dist/utils.js
function clone(data) {
  if ("structuredClone" in globalThis) {
    return structuredClone(data);
  }
  return parse(stringify(data));
}

// node_modules/.pnpm/sveltekit-superforms@1.5.0_@sveltejs+kit@1.22.4_svelte@4.1.2_vite@4.4.8_@types+node@18.17.1___svelte@4.1.2_zod@3.21.4/node_modules/sveltekit-superforms/dist/schemaEntity.js
function unwrapZodType(zodType) {
  const originalType = zodType;
  let _wrapped = true;
  let isNullable = false;
  let isOptional = false;
  let hasDefault = false;
  let effects = void 0;
  let defaultValue = void 0;
  while (_wrapped) {
    if (zodType._def.typeName == "ZodNullable") {
      isNullable = true;
      zodType = zodType.unwrap();
    } else if (zodType._def.typeName == "ZodDefault") {
      hasDefault = true;
      defaultValue = zodType._def.defaultValue();
      zodType = zodType._def.innerType;
    } else if (zodType._def.typeName == "ZodOptional") {
      isOptional = true;
      zodType = zodType.unwrap();
    } else if (zodType._def.typeName == "ZodEffects") {
      if (!effects)
        effects = zodType;
      zodType = zodType._def.schema;
    } else if (zodType._def.typeName == "ZodPipeline") {
      zodType = zodType._def.out;
    } else {
      _wrapped = false;
    }
  }
  return {
    zodType,
    originalType,
    isNullable,
    isOptional,
    hasDefault,
    defaultValue,
    effects
  };
}
function hashCode(str) {
  let hash = 0;
  for (let i = 0, len = str.length; i < len; i++) {
    const chr = str.charCodeAt(i);
    hash = (hash << 5) - hash + chr;
    hash |= 0;
  }
  if (hash < 0)
    hash = hash >>> 0;
  return hash.toString(36);
}
function entityHash(schema) {
  return hashCode(_entityHash(schema));
}
function _entityHash(type) {
  let hash = "";
  const unwrapped = unwrapZodType(type);
  switch (unwrapped.zodType._def.typeName) {
    case "ZodObject": {
      for (const [field, zodType] of Object.entries(unwrapped.zodType.shape)) {
        hash += "ZodObject:" + field + ":" + _entityHash(zodType);
      }
      break;
    }
    case "ZodArray": {
      const inner = unwrapped.zodType;
      hash += "ZodArray:" + _entityHash(inner.element);
      break;
    }
    default:
      hash += unwrapped.zodType._def.typeName;
  }
  return hash;
}
function entityData(schema, warnings) {
  const cached = getCached(schema);
  if (cached)
    return cached;
  const entity = {
    typeInfo: schemaInfo(schema),
    defaultEntity: defaultValues(schema),
    constraints: constraints(schema, warnings),
    keys: Object.keys(schema.keyof().Values),
    hash: entityHash(schema),
    errorShape: errorShape(schema)
  };
  setCached(schema, entity);
  return entity;
}
function setCached(schema, entity) {
  entityCache.set(schema, entity);
}
function getCached(schema) {
  return entityCache.get(schema);
}
var entityCache = /* @__PURE__ */ new WeakMap();
function schemaInfo(schema) {
  return _mapSchema(schema, (obj) => unwrapZodType(obj));
}
function valueOrDefault(value, strict, implicitDefaults, schemaInfo2) {
  if (value)
    return value;
  const { zodType, isNullable, isOptional, hasDefault, defaultValue } = schemaInfo2;
  if (strict && value !== void 0)
    return value;
  if (hasDefault)
    return defaultValue;
  if (isNullable)
    return null;
  if (isOptional)
    return void 0;
  if (implicitDefaults) {
    if (zodType._def.typeName == "ZodString")
      return "";
    if (zodType._def.typeName == "ZodNumber")
      return 0;
    if (zodType._def.typeName == "ZodBoolean")
      return false;
    if (zodType._def.typeName == "ZodArray")
      return [];
    if (zodType._def.typeName == "ZodObject") {
      return defaultValues(zodType);
    }
    if (zodType._def.typeName == "ZodSet")
      return /* @__PURE__ */ new Set();
    if (zodType._def.typeName == "ZodRecord")
      return {};
    if (zodType._def.typeName == "ZodBigInt")
      return BigInt(0);
    if (zodType._def.typeName == "ZodSymbol")
      return Symbol();
  }
  return void 0;
}
function defaultValues(schema) {
  while (schema._def.typeName == "ZodEffects") {
    schema = schema._def.schema;
  }
  if (!(schema._def.typeName == "ZodObject")) {
    throw new SuperFormError("Only Zod schema objects can be used with defaultValues. Define the schema with z.object({ ... }) and optionally refine/superRefine/transform at the end.");
  }
  const realSchema = schema;
  const fields = Object.keys(realSchema.keyof().Values);
  const schemaTypeInfo = schemaInfo(realSchema);
  return Object.fromEntries(fields.map((field) => {
    const typeInfo = schemaTypeInfo[field];
    const newValue = valueOrDefault(void 0, true, true, typeInfo);
    return [field, newValue];
  }));
}
function constraints(schema, warnings) {
  function constraint(key, zodType, info) {
    const output = {};
    if (zodType._def.typeName == "ZodString") {
      const zodString = zodType;
      const patterns = zodString._def.checks.filter((f) => f.kind == "regex");
      if (patterns.length > 1 && (warnings == null ? void 0 : warnings.multipleRegexps) !== false) {
        console.warn(`Field "${key}" has more than one regexp, only the first one will be used in constraints. Set the warnings.multipleRegexps option to false to disable this warning.`);
      }
      const pattern = patterns.length > 0 && patterns[0].kind == "regex" ? patterns[0].regex.source : void 0;
      if (pattern)
        output.pattern = pattern;
      if (zodString.minLength !== null)
        output.minlength = zodString.minLength;
      if (zodString.maxLength !== null)
        output.maxlength = zodString.maxLength;
    } else if (zodType._def.typeName == "ZodNumber") {
      const zodNumber = zodType;
      const steps = zodNumber._def.checks.filter((f) => f.kind == "multipleOf");
      if (steps.length > 1 && (warnings == null ? void 0 : warnings.multipleSteps) !== false) {
        console.warn(`Field "${key}" has more than one step, only the first one will be used in constraints. Set the warnings.multipleSteps option to false to disable this warning.`);
      }
      const step = steps.length > 0 && steps[0].kind == "multipleOf" ? steps[0].value : null;
      if (zodNumber.minValue !== null)
        output.min = zodNumber.minValue;
      if (zodNumber.maxValue !== null)
        output.max = zodNumber.maxValue;
      if (step !== null)
        output.step = step;
    } else if (zodType._def.typeName == "ZodDate") {
      const zodDate = zodType;
      if (zodDate.minDate)
        output.min = zodDate.minDate.toISOString();
      if (zodDate.maxDate)
        output.max = zodDate.maxDate.toISOString();
    } else if (zodType._def.typeName == "ZodArray") {
      if (zodType._def.minLength)
        output.min = zodType._def.minLength.value;
      if (zodType._def.maxLength)
        output.max = zodType._def.maxLength.value;
      if (zodType._def.exactLength)
        output.min = output.max = zodType._def.exactLength.value;
    }
    if (!info.isNullable && !info.isOptional) {
      output.required = true;
    }
    return Object.keys(output).length > 0 ? output : void 0;
  }
  function mapField(key, value) {
    const info = unwrapZodType(value);
    value = info.zodType;
    if (value._def.typeName == "ZodArray") {
      return mapField(key, value._def.type);
    } else if (value._def.typeName == "ZodObject") {
      return constraints(value, warnings);
    } else {
      return constraint(key, value, info);
    }
  }
  return _mapSchema(schema, (obj, key) => {
    return mapField(key, obj);
  }, (data) => !!data);
}
function _mapSchema(schema, factory, filter) {
  const keys = schema.keyof().Values;
  return Object.fromEntries(Object.keys(keys).map((key) => [key, factory(schema.shape[key], key)]).filter((entry) => filter ? filter(entry[1]) : true));
}

// node_modules/.pnpm/sveltekit-superforms@1.5.0_@sveltejs+kit@1.22.4_svelte@4.1.2_vite@4.4.8_@types+node@18.17.1___svelte@4.1.2_zod@3.21.4/node_modules/sveltekit-superforms/dist/errors.js
var _cachedErrorShapes = /* @__PURE__ */ new WeakMap();
function errorShape(schema) {
  if (!_cachedErrorShapes.has(schema)) {
    _cachedErrorShapes.set(schema, _errorShape(schema));
  }
  return _cachedErrorShapes.get(schema);
}
function _errorShape(type) {
  const unwrapped = unwrapZodType(type).zodType;
  if (unwrapped._def.typeName == "ZodObject") {
    return Object.fromEntries(Object.entries(unwrapped.shape).map(([key, value]) => {
      return [key, _errorShape(value)];
    }).filter((entry) => entry[1] !== void 0));
  } else if (unwrapped._def.typeName == "ZodArray") {
    return _errorShape(unwrapped._def.type) ?? {};
  } else if (unwrapped._def.typeName == "ZodRecord") {
    return _errorShape(unwrapped._def.valueType) ?? {};
  } else if (unwrapped._def.typeName == "ZodUnion") {
    const options = unwrapped._def.options;
    return options.reduce((shape, next) => {
      const nextShape = _errorShape(next);
      if (nextShape)
        shape = { ...shape ?? {}, ...nextShape };
      return shape;
    }, void 0);
  }
  return void 0;
}
function mapErrors(obj, errorShape2, inObject = true) {
  const output = {};
  const entries = Object.entries(obj);
  if ("_errors" in obj && obj._errors.length) {
    if (!errorShape2 || !inObject) {
      return obj._errors;
    } else {
      output._errors = obj._errors;
    }
  }
  for (const [key, value] of entries.filter(([key2]) => key2 !== "_errors")) {
    const numericKey = !isNaN(parseInt(key, 10));
    output[key] = mapErrors(
      value,
      errorShape2 ? numericKey ? errorShape2 : errorShape2[key] : void 0,
      !!(errorShape2 == null ? void 0 : errorShape2[key])
      // We're not in an object if there is no key in the ErrorShape
    );
  }
  return output;
}
function flattenErrors(errors) {
  return _flattenErrors(errors, []);
}
function _flattenErrors(errors, path) {
  const entries = Object.entries(errors);
  return entries.filter(([, value]) => value !== void 0).flatMap(([key, messages]) => {
    if (Array.isArray(messages) && messages.length > 0) {
      const currPath = path.concat([key]);
      return { path: mergePath(currPath), messages };
    } else {
      return _flattenErrors(errors[key], path.concat([key]));
    }
  });
}
function clearErrors(Errors, options) {
  Errors.update(($errors) => {
    traversePaths($errors, (pathData) => {
      if (pathData.path.length == 1 && pathData.path[0] == "_errors" && !options.clearFormLevelErrors) {
        return;
      }
      if (Array.isArray(pathData.value)) {
        return pathData.set(void 0);
      }
    });
    if (options.undefinePath)
      setPaths($errors, [options.undefinePath], void 0);
    return $errors;
  });
}

// node_modules/.pnpm/sveltekit-superforms@1.5.0_@sveltejs+kit@1.22.4_svelte@4.1.2_vite@4.4.8_@types+node@18.17.1___svelte@4.1.2_zod@3.21.4/node_modules/sveltekit-superforms/dist/client/clientValidation.js
async function clientValidation(options, checkData, formId, constraints2, posted) {
  return _clientValidation(options.validators, checkData, formId, constraints2, posted);
}
async function _clientValidation(validators, checkData, formId, constraints2, posted) {
  if (validators) {
    let valid;
    let clientErrors = {};
    if ("safeParseAsync" in validators) {
      const validator = validators;
      const result = await validator.safeParseAsync(checkData);
      valid = result.success;
      if (!result.success) {
        clientErrors = mapErrors(
          result.error.format(),
          errorShape(validator)
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
        );
      }
    } else {
      valid = true;
      const validator = validators;
      const newErrors = [];
      await traversePathsAsync(checkData, async ({ value, path }) => {
        const validationPath = path.filter((p) => isNaN(parseInt(p)));
        const maybeValidator = traversePath(validator, validationPath);
        if (typeof (maybeValidator == null ? void 0 : maybeValidator.value) === "function") {
          const check = maybeValidator.value;
          if (Array.isArray(value)) {
            for (const key in value) {
              const errors = await check(value[key]);
              if (errors) {
                valid = false;
                newErrors.push({
                  path: path.concat([key]),
                  errors: typeof errors === "string" ? [errors] : errors ?? void 0
                });
              }
            }
          } else {
            const errors = await check(value);
            if (errors) {
              valid = false;
              newErrors.push({
                path,
                errors: typeof errors === "string" ? [errors] : errors ?? void 0
              });
            }
          }
        }
      });
      for (const { path, errors } of newErrors) {
        const errorPath = traversePath(clientErrors, path, ({ parent, key, value }) => {
          if (value === void 0)
            parent[key] = {};
          return parent[key];
        });
        if (errorPath) {
          const { parent, key } = errorPath;
          parent[key] = errors;
        }
      }
    }
    if (!valid) {
      return {
        valid: false,
        posted,
        errors: clientErrors,
        data: checkData,
        constraints: constraints2,
        message: void 0,
        id: formId
      };
    }
  }
  return {
    valid: true,
    posted,
    errors: {},
    data: checkData,
    constraints: constraints2,
    message: void 0,
    id: formId
  };
}
async function validateObjectErrors(formOptions, data, Errors) {
  if (typeof formOptions.validators !== "object" || !("safeParseAsync" in formOptions.validators)) {
    return;
  }
  const validators = formOptions.validators;
  const result = await validators.safeParseAsync(data);
  if (!result.success) {
    const newErrors = mapErrors(result.error.format(), errorShape(validators));
    Errors.update((currentErrors) => {
      traversePaths(currentErrors, (pathData) => {
        if (pathData.key == "_errors") {
          return pathData.set(void 0);
        }
      });
      traversePaths(newErrors, (pathData) => {
        if (pathData.key == "_errors") {
          return setPaths(currentErrors, [pathData.path], pathData.value);
        }
      });
      return currentErrors;
    });
  } else {
    Errors.update((currentErrors) => {
      traversePaths(currentErrors, (pathData) => {
        if (pathData.key == "_errors") {
          return pathData.set(void 0);
        }
      });
      return currentErrors;
    });
  }
}
async function validateField(path, formOptions, data, Errors, Tainted, options = {}) {
  function Errors_clear() {
    clearErrors(Errors, { undefinePath: path, clearFormLevelErrors: true });
  }
  function Errors_update(errorMsgs) {
    if (typeof errorMsgs === "string")
      errorMsgs = [errorMsgs];
    if (options.update === true || options.update == "errors") {
      Errors.update((errors2) => {
        const error = traversePath(errors2, path, (node) => {
          if (isInvalidPath(path, node)) {
            throw new SuperFormError("Errors can only be added to form fields, not to arrays or objects in the schema. Path: " + node.path.slice(0, -1));
          } else if (node.value === void 0) {
            node.parent[node.key] = {};
            return node.parent[node.key];
          } else {
            return node.value;
          }
        });
        if (!error)
          throw new SuperFormError("Error path could not be created: " + path);
        error.parent[error.key] = errorMsgs ?? void 0;
        return errors2;
      });
    }
    return errorMsgs ?? void 0;
  }
  const errors = await _validateField(path, formOptions.validators, data, Errors, Tainted, options);
  if (errors.validated) {
    if (errors.validated === "all" && !errors.errors) {
      Errors_clear();
    } else {
      return Errors_update(errors.errors);
    }
  } else if (errors.validated === false && formOptions.defaultValidator == "clear") {
    return Errors_update(void 0);
  }
  return errors.errors;
}
async function _validateField(path, validators, data, Errors, Tainted, options = {}) {
  if (options.update === void 0)
    options.update = true;
  if (options.taint === void 0)
    options.taint = false;
  if (typeof options.errors == "string")
    options.errors = [options.errors];
  const Context = {
    value: options.value,
    shouldUpdate: true,
    currentData: void 0,
    // Remove numeric indices, they're not used for validators.
    validationPath: path.filter((p) => isNaN(parseInt(p)))
  };
  async function defaultValidate() {
    return { validated: false, errors: void 0 };
  }
  function Tainted_isPathTainted(path2, tainted) {
    if (tainted === void 0)
      return false;
    const leaf = traversePath(tainted, path2);
    if (!leaf)
      return false;
    return leaf.value === true;
  }
  function Errors_update(updater) {
    Errors.update(updater);
  }
  function Errors_clearFormLevelErrors() {
    Errors.update(($errors) => {
      traversePaths($errors, (path2) => {
        if (path2.key == "_errors")
          return path2.set(void 0);
      });
      return $errors;
    });
  }
  function Errors_fromZod(errors, validator) {
    return mapErrors(errors.format(), errorShape(validator));
  }
  if (!("value" in options)) {
    Context.currentData = get_store_value(data);
    const dataToValidate2 = traversePath(Context.currentData, path);
    Context.value = dataToValidate2 == null ? void 0 : dataToValidate2.value;
  } else if (options.update === true || options.update === "value") {
    data.update(($data) => {
      setPaths($data, [path], Context.value);
      return Context.currentData = $data;
    }, { taint: options.taint });
  } else {
    Context.shouldUpdate = false;
  }
  if (typeof validators !== "object") {
    return defaultValidate();
  }
  if ("safeParseAsync" in validators) {
    if (!Context.shouldUpdate) {
      Context.currentData = clone(Context.currentData ?? get_store_value(data));
      setPaths(Context.currentData, [path], Context.value);
    }
    const result = await validators.safeParseAsync(Context.currentData);
    if (!result.success) {
      const newErrors = Errors_fromZod(result.error, validators);
      if (options.update === true || options.update == "errors") {
        const taintedFields = get_store_value(Tainted);
        Errors_update((currentErrors) => {
          traversePaths(currentErrors, (pathData) => {
            if (pathData.key == "_errors") {
              return pathData.set(void 0);
            }
          });
          traversePaths(newErrors, (pathData) => {
            if (pathData.key == "_errors") {
              return setPaths(currentErrors, [pathData.path], pathData.value);
            }
            if (!Array.isArray(pathData.value))
              return;
            if (Tainted_isPathTainted(pathData.path, taintedFields)) {
              setPaths(currentErrors, [pathData.path], pathData.value);
            }
            return "skip";
          });
          return currentErrors;
        });
      }
      const current = traversePath(newErrors, path);
      return {
        validated: true,
        errors: options.errors ?? (current == null ? void 0 : current.value)
      };
    } else {
      Errors_clearFormLevelErrors();
      return { validated: true, errors: void 0 };
    }
  } else {
    const validator = traversePath(validators, Context.validationPath);
    if (!validator) {
      throw new SuperFormError("No Superforms validator found: " + path);
    } else if (validator.value === void 0) {
      return defaultValidate();
    } else {
      const result = await validator.value(Context.value);
      return {
        validated: true,
        errors: result ? options.errors ?? result : result
      };
    }
  }
}

// node_modules/.pnpm/sveltekit-superforms@1.5.0_@sveltejs+kit@1.22.4_svelte@4.1.2_vite@4.4.8_@types+node@18.17.1___svelte@4.1.2_zod@3.21.4/node_modules/sveltekit-superforms/dist/client/formEnhance.js
import { enhance, applyAction } from "$app/forms";
import { invalidateAll } from "$app/navigation";
import { page } from "$app/stores";
import { browser } from "$app/environment";

// node_modules/.pnpm/sveltekit-superforms@1.5.0_@sveltejs+kit@1.22.4_svelte@4.1.2_vite@4.4.8_@types+node@18.17.1___svelte@4.1.2_zod@3.21.4/node_modules/sveltekit-superforms/dist/client/elements.js
var isElementInViewport = (el, topOffset = 0) => {
  const rect = el.getBoundingClientRect();
  return rect.top >= topOffset && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth);
};
var scrollToAndCenter = (el, offset = 1.125, behavior = "smooth") => {
  const elementRect = el.getBoundingClientRect();
  const absoluteElementTop = elementRect.top + window.pageYOffset;
  const top = absoluteElementTop - window.innerHeight / (2 * offset);
  window.scrollTo({ left: 0, top, behavior });
};

// node_modules/.pnpm/sveltekit-superforms@1.5.0_@sveltejs+kit@1.22.4_svelte@4.1.2_vite@4.4.8_@types+node@18.17.1___svelte@4.1.2_zod@3.21.4/node_modules/sveltekit-superforms/dist/client/form.js
import { afterNavigate } from "$app/navigation";
var FetchStatus;
(function(FetchStatus2) {
  FetchStatus2[FetchStatus2["Idle"] = 0] = "Idle";
  FetchStatus2[FetchStatus2["Submitting"] = 1] = "Submitting";
  FetchStatus2[FetchStatus2["Delayed"] = 2] = "Delayed";
  FetchStatus2[FetchStatus2["Timeout"] = 3] = "Timeout";
})(FetchStatus || (FetchStatus = {}));
var activeTimers = /* @__PURE__ */ new Set();
var _initialized = false;
function Form(formEl, timers, options) {
  let state = FetchStatus.Idle;
  let delayedTimeout, timeoutTimeout;
  const Timers = activeTimers;
  function Timers_start() {
    Timers_clear();
    Timers_setState(state != FetchStatus.Delayed ? FetchStatus.Submitting : FetchStatus.Delayed);
    delayedTimeout = window.setTimeout(() => {
      if (delayedTimeout && state == FetchStatus.Submitting)
        Timers_setState(FetchStatus.Delayed);
    }, options.delayMs);
    timeoutTimeout = window.setTimeout(() => {
      if (timeoutTimeout && state == FetchStatus.Delayed)
        Timers_setState(FetchStatus.Timeout);
    }, options.timeoutMs);
    Timers.add(Timers_clear);
  }
  function Timers_clear() {
    clearTimeout(delayedTimeout);
    clearTimeout(timeoutTimeout);
    delayedTimeout = timeoutTimeout = 0;
    Timers.delete(Timers_clear);
    Timers_setState(FetchStatus.Idle);
  }
  function Timers_clearAll() {
    Timers.forEach((t) => t());
    Timers.clear();
  }
  function Timers_setState(s) {
    state = s;
    timers.submitting.set(state >= FetchStatus.Submitting);
    timers.delayed.set(state >= FetchStatus.Delayed);
    timers.timeout.set(state >= FetchStatus.Timeout);
  }
  const ErrorTextEvents = formEl;
  function ErrorTextEvents__selectText(e) {
    const target = e.target;
    if (options.selectErrorText)
      target.select();
  }
  function ErrorTextEvents_addErrorTextListeners() {
    if (!options.selectErrorText)
      return;
    ErrorTextEvents.querySelectorAll("input").forEach((el) => {
      el.addEventListener("invalid", ErrorTextEvents__selectText);
    });
  }
  function ErrorTextEvents_removeErrorTextListeners() {
    if (!options.selectErrorText)
      return;
    ErrorTextEvents.querySelectorAll("input").forEach((el) => el.removeEventListener("invalid", ErrorTextEvents__selectText));
  }
  const Form2 = formEl;
  function Form_shouldAutoFocus(userAgent) {
    if (typeof options.autoFocusOnError === "boolean")
      return options.autoFocusOnError;
    else
      return !/iPhone|iPad|iPod|Android/i.test(userAgent);
  }
  const Form_scrollToFirstError = async () => {
    if (options.scrollToError == "off")
      return;
    const selector = options.errorSelector;
    if (!selector)
      return;
    await tick();
    let el;
    el = Form2.querySelector(selector);
    if (!el)
      return;
    el = el.querySelector(selector) ?? el;
    const nav = options.stickyNavbar ? document.querySelector(options.stickyNavbar) : null;
    if (typeof options.scrollToError != "string") {
      el.scrollIntoView(options.scrollToError);
    } else if (!isElementInViewport(el, (nav == null ? void 0 : nav.offsetHeight) ?? 0)) {
      scrollToAndCenter(el, void 0, options.scrollToError);
    }
    if (!Form_shouldAutoFocus(navigator.userAgent))
      return;
    let focusEl;
    focusEl = el;
    if (!["INPUT", "SELECT", "BUTTON", "TEXTAREA"].includes(focusEl.tagName)) {
      focusEl = focusEl.querySelector('input:not([type="hidden"]):not(.flatpickr-input), select, textarea');
    }
    if (focusEl) {
      try {
        focusEl.focus({ preventScroll: true });
        if (options.selectErrorText && focusEl.tagName == "INPUT") {
          focusEl.select();
        }
      } catch (err) {
      }
    }
  };
  {
    ErrorTextEvents_addErrorTextListeners();
    const completed = (cancelled) => {
      Timers_clear();
      if (!cancelled)
        setTimeout(Form_scrollToFirstError);
    };
    onDestroy(() => {
      ErrorTextEvents_removeErrorTextListeners();
      completed(true);
    });
    if (!_initialized) {
      afterNavigate((nav) => {
        if (nav.type != "enter")
          Timers_clearAll();
      });
      _initialized = true;
    }
    return {
      submitting: () => {
        Timers_start();
      },
      completed,
      scrollToFirstError: () => {
        setTimeout(Form_scrollToFirstError);
      },
      isSubmitting: () => state === FetchStatus.Submitting || state === FetchStatus.Delayed
    };
  }
}

// node_modules/.pnpm/sveltekit-superforms@1.5.0_@sveltejs+kit@1.22.4_svelte@4.1.2_vite@4.4.8_@types+node@18.17.1___svelte@4.1.2_zod@3.21.4/node_modules/sveltekit-superforms/dist/client/formEnhance.js
function cancelFlash(options) {
  if (!options.flashMessage || !browser)
    return;
  if (!shouldSyncFlash(options))
    return;
  document.cookie = `flash=; Max-Age=0; Path=${options.flashMessage.cookiePath ?? "/"};`;
}
function shouldSyncFlash(options) {
  if (!options.flashMessage || !browser)
    return false;
  return options.syncFlashMessage;
}
var noCustomValidityDataAttribute = "noCustomValidity";
function setCustomValidity(el, errors) {
  const message2 = errors && errors.length ? errors.join("\n") : "";
  el.setCustomValidity(message2);
  if (message2)
    el.reportValidity();
}
function setCustomValidityForm(formEl, errors) {
  for (const el of formEl.querySelectorAll("input")) {
    if (noCustomValidityDataAttribute in el.dataset)
      continue;
    const error = traversePath(errors, splitPath(el.name));
    setCustomValidity(el, error == null ? void 0 : error.value);
    if (error == null ? void 0 : error.value)
      return;
  }
}
function formEnhance(formEl, submitting, delayed, timeout, errs, Form_updateFromActionResult, options, data, message2, enableTaintedForm, formEvents, formId, constraints2, tainted, lastChanges, Context_findValidationForms, posted) {
  enableTaintedForm();
  const errors = errs;
  async function validateChange(change, event, validityEl) {
    if (options.customValidity && validityEl) {
      if ("setCustomValidity" in validityEl) {
        validityEl.setCustomValidity("");
      }
      if (noCustomValidityDataAttribute in validityEl.dataset)
        if (event == "input")
          return;
        else
          validityEl = null;
    }
    const newErrors = await validateField(change, options, data, errors, tainted);
    if (validityEl) {
      setCustomValidity(validityEl, newErrors);
    }
  }
  function timingIssue(el) {
    return el && (el instanceof HTMLSelectElement || el instanceof HTMLInputElement && (el.type == "radio" || el.type == "checkbox"));
  }
  async function checkBlur(e) {
    if (options.validationMethod == "oninput" || options.validationMethod == "submit-only") {
      return;
    }
    if (timingIssue(e.target)) {
      await new Promise((r) => setTimeout(r, 0));
    }
    for (const change of get_store_value(lastChanges)) {
      let validityEl = null;
      if (options.customValidity) {
        const name = CSS.escape(mergePath(change));
        validityEl = formEl.querySelector(`[name="${name}"]`);
      }
      validateChange(change, "blur", validityEl);
    }
    lastChanges.set([]);
  }
  formEl.addEventListener("focusout", checkBlur);
  async function checkCustomValidity(e) {
    if (timingIssue(e.target)) {
      await new Promise((r) => setTimeout(r, 0));
    }
    for (const change of get_store_value(lastChanges)) {
      const name = CSS.escape(mergePath(change));
      const validityEl = formEl.querySelector(`[name="${name}"]`);
      if (!validityEl)
        continue;
      const hadErrors = traversePath(get_store_value(errors), change);
      if (hadErrors && hadErrors.key in hadErrors.parent) {
        setTimeout(() => validateChange(change, "input", validityEl), 0);
      }
    }
  }
  if (options.customValidity) {
    formEl.addEventListener("input", checkCustomValidity);
  }
  onDestroy(() => {
    formEl.removeEventListener("focusout", checkBlur);
    formEl.removeEventListener("input", checkCustomValidity);
  });
  const htmlForm = Form(formEl, { submitting, delayed, timeout }, options);
  let currentRequest;
  return enhance(formEl, async (submit) => {
    var _a;
    const submitCancel = submit.cancel;
    let cancelled = false;
    function cancel() {
      cancelled = true;
      return submitCancel();
    }
    submit.cancel = cancel;
    if (htmlForm.isSubmitting() && options.multipleSubmits == "prevent") {
      cancel();
    } else {
      if (htmlForm.isSubmitting() && options.multipleSubmits == "abort") {
        if (currentRequest)
          currentRequest.abort();
      }
      currentRequest = submit.controller;
      for (const event of formEvents.onSubmit) {
        await event(submit);
      }
    }
    if (cancelled) {
      if (options.flashMessage)
        cancelFlash(options);
    } else {
      const validation = await clientValidation(options, get_store_value(data), get_store_value(formId), get_store_value(constraints2), get_store_value(posted));
      if (!validation.valid) {
        cancel();
        const result = {
          type: "failure",
          status: (typeof options.SPA === "boolean" ? void 0 : (_a = options.SPA) == null ? void 0 : _a.failStatus) ?? 400,
          data: { form: validation }
        };
        setTimeout(() => validationResponse({ result }), 0);
      }
      if (!cancelled) {
        switch (options.clearOnSubmit) {
          case "errors-and-message":
            errors.clear();
            message2.set(void 0);
            break;
          case "errors":
            errors.clear();
            break;
          case "message":
            message2.set(void 0);
            break;
        }
        if (options.flashMessage && (options.clearOnSubmit == "errors-and-message" || options.clearOnSubmit == "message") && shouldSyncFlash(options)) {
          options.flashMessage.module.getFlash(page).set(void 0);
        }
        htmlForm.submitting();
        const submitData = "formData" in submit ? submit.formData : submit.data;
        if (options.SPA) {
          cancel();
          const validationResult = {
            valid: true,
            posted: true,
            errors: {},
            data: get_store_value(data),
            constraints: get_store_value(constraints2),
            message: void 0,
            id: get_store_value(formId)
          };
          const result = {
            type: "success",
            status: 200,
            data: { form: validationResult }
          };
          setTimeout(() => validationResponse({ result }), 0);
        } else if (options.dataType === "json") {
          const postData = get_store_value(data);
          const chunks = chunkSubstr(stringify(postData), options.jsonChunkSize ?? 5e5);
          for (const chunk of chunks) {
            submitData.append("__superform_json", chunk);
          }
          Object.keys(postData).forEach((key) => {
            if (typeof submitData.get(key) === "string") {
              submitData.delete(key);
            }
          });
        }
        if (!options.SPA && !submitData.has("__superform_id")) {
          const id = get_store_value(formId);
          if (id !== void 0)
            submitData.set("__superform_id", id);
        }
      }
    }
    function chunkSubstr(str, size) {
      const numChunks = Math.ceil(str.length / size);
      const chunks = new Array(numChunks);
      for (let i = 0, o = 0; i < numChunks; ++i, o += size) {
        chunks[i] = str.substring(o, o + size);
      }
      return chunks;
    }
    async function validationResponse(event) {
      const result = event.result;
      currentRequest = null;
      let cancelled2 = false;
      const data2 = {
        result,
        formEl,
        cancel: () => cancelled2 = true
      };
      for (const event2 of formEvents.onResult) {
        await event2(data2);
      }
      if (!cancelled2) {
        if ((result.type === "success" || result.type == "failure") && result.data) {
          const forms = Context_findValidationForms(result.data);
          if (!forms.length) {
            throw new SuperFormError("No form data returned from ActionResult. Make sure you return { form } in the form actions.");
          }
          for (const newForm of forms) {
            if (newForm.id !== get_store_value(formId))
              continue;
            const data3 = {
              form: newForm,
              formEl,
              cancel: () => cancelled2 = true
            };
            for (const event2 of formEvents.onUpdate) {
              await event2(data3);
            }
            if (!cancelled2 && options.customValidity) {
              setCustomValidityForm(formEl, data3.form.errors);
            }
          }
        }
        if (!cancelled2) {
          if (result.type !== "error") {
            if (result.type === "success" && options.invalidateAll) {
              await invalidateAll();
            }
            if (options.applyAction) {
              await applyAction(result);
            } else {
              await Form_updateFromActionResult(result);
            }
          } else {
            if (options.applyAction) {
              if (options.onError == "apply") {
                await applyAction(result);
              } else {
                const failResult = {
                  type: "failure",
                  status: Math.floor(result.status || 500),
                  data: result
                };
                await applyAction(failResult);
              }
            }
            if (options.onError !== "apply") {
              const data3 = { result, message: message2 };
              for (const event2 of formEvents.onError) {
                if (event2 !== "apply")
                  await event2(data3);
              }
            }
          }
          if (options.flashMessage) {
            if (result.type == "error" && options.flashMessage.onError) {
              await options.flashMessage.onError({
                result,
                message: options.flashMessage.module.getFlash(page)
              });
            }
          }
        }
      }
      if (cancelled2 && options.flashMessage) {
        cancelFlash(options);
      }
      if (cancelled2 || result.type != "redirect") {
        htmlForm.completed(cancelled2);
      }
    }
    return validationResponse;
  });
}

// node_modules/.pnpm/sveltekit-superforms@1.5.0_@sveltejs+kit@1.22.4_svelte@4.1.2_vite@4.4.8_@types+node@18.17.1___svelte@4.1.2_zod@3.21.4/node_modules/sveltekit-superforms/dist/superValidate.js
import { fail, json } from "@sveltejs/kit";
function message(form, message2, options) {
  if ((options == null ? void 0 : options.status) && options.status >= 400) {
    form.valid = false;
  }
  form.message = message2;
  return !form.valid ? fail((options == null ? void 0 : options.status) ?? 400, { form }) : { form };
}
var setMessage = message;
function setError(form, path, error, options) {
  if (error == void 0 || typeof error !== "string" && !Array.isArray(error)) {
    options = error;
    error = path;
    path = "";
  }
  if (options === void 0)
    options = {};
  const errArr = Array.isArray(error) ? error : [error];
  if (!form.errors)
    form.errors = {};
  if (path === null || path === "") {
    if (!form.errors._errors)
      form.errors._errors = [];
    form.errors._errors = options.overwrite ? errArr : form.errors._errors.concat(errArr);
  } else {
    const realPath = splitPath(path);
    const leaf = traversePath(form.errors, realPath, ({ parent, key, value }) => {
      if (value === void 0)
        parent[key] = {};
      return parent[key];
    });
    if (leaf) {
      leaf.parent[leaf.key] = Array.isArray(leaf.value) && !options.overwrite ? leaf.value.concat(errArr) : errArr;
    }
  }
  form.valid = false;
  return fail(options.status ?? 400, { form });
}
function formDataToValidation(data, schemaData) {
  const output = {};
  const { schemaKeys, entityInfo } = schemaData;
  function parseSingleEntry(key, entry, typeInfo) {
    if (entry && typeof entry !== "string") {
      return void 0;
    } else {
      return parseFormDataEntry(key, entry, typeInfo);
    }
  }
  for (const key of schemaKeys) {
    const typeInfo = entityInfo.typeInfo[key];
    const entries = data.getAll(key);
    if (!(typeInfo.zodType._def.typeName == "ZodArray")) {
      output[key] = parseSingleEntry(key, entries[0], typeInfo);
    } else {
      const arrayType = unwrapZodType(typeInfo.zodType._def.type);
      output[key] = entries.map((e) => parseSingleEntry(key, e, arrayType));
    }
  }
  function parseFormDataEntry(field, value, typeInfo) {
    const newValue = valueOrDefault(value, false, true, typeInfo);
    const zodType = typeInfo.zodType;
    if (!value && zodType._def.typeName != "ZodBoolean") {
      return newValue;
    }
    if (zodType._def.typeName == "ZodString") {
      return value;
    } else if (zodType._def.typeName == "ZodNumber") {
      return zodType.isInt ? parseInt(value ?? "", 10) : parseFloat(value ?? "");
    } else if (zodType._def.typeName == "ZodBoolean") {
      return Boolean(value == "false" ? "" : value).valueOf();
    } else if (zodType._def.typeName == "ZodDate") {
      return new Date(value ?? "");
    } else if (zodType._def.typeName == "ZodArray") {
      const arrayType = unwrapZodType(zodType._def.type);
      return parseFormDataEntry(field, value, arrayType);
    } else if (zodType._def.typeName == "ZodBigInt") {
      try {
        return BigInt(value ?? ".");
      } catch {
        return NaN;
      }
    } else if (zodType._def.typeName == "ZodLiteral") {
      const literalType = typeof zodType.value;
      if (literalType === "string")
        return value;
      else if (literalType === "number")
        return parseFloat(value ?? "");
      else if (literalType === "boolean")
        return Boolean(value).valueOf();
      else {
        throw new SuperFormError("Unsupported ZodLiteral type: " + literalType);
      }
    } else if (zodType._def.typeName == "ZodUnion" || zodType._def.typeName == "ZodEnum" || zodType._def.typeName == "ZodAny") {
      return value;
    } else if (zodType._def.typeName == "ZodNativeEnum") {
      const zodEnum = zodType;
      if (value !== null && value in zodEnum.enum) {
        const enumValue = zodEnum.enum[value];
        if (typeof enumValue === "number")
          return enumValue;
        else if (enumValue in zodEnum.enum)
          return zodEnum.enum[enumValue];
      } else if (value !== null && Object.values(zodEnum.enum).includes(value)) {
        return value;
      }
      return void 0;
    } else if (zodType._def.typeName == "ZodSymbol") {
      return Symbol(String(value));
    }
    if (zodType._def.typeName == "ZodObject") {
      throw new SuperFormError(`Object found in form field "${field}". Set the dataType option to "json" and add use:enhance on the client to use nested data structures. More information: https://superforms.rocks/concepts/nested-data`);
    }
    throw new SuperFormError("Unsupported Zod default type: " + zodType.constructor.name);
  }
  return output;
}
function dataToValidate(parsed, schemaData) {
  if (!parsed.data) {
    return schemaData.hasEffects || schemaData.opts.errors === true ? schemaData.entityInfo.defaultEntity : void 0;
  } else {
    return parsed.data;
  }
}
function parseFormData(formData, schemaData) {
  var _a;
  function tryParseSuperJson() {
    if (formData.has("__superform_json")) {
      try {
        const output = parse(formData.getAll("__superform_json").join("") ?? "");
        if (typeof output === "object") {
          return output;
        }
      } catch {
      }
    }
    return null;
  }
  const data = tryParseSuperJson();
  const id = ((_a = formData.get("__superform_id")) == null ? void 0 : _a.toString()) ?? void 0;
  return data ? { id, data, posted: true } : {
    id,
    data: formDataToValidation(formData, schemaData),
    posted: true
  };
}
function parseSearchParams(data, schemaData) {
  if (data instanceof URL)
    data = data.searchParams;
  const convert = new FormData();
  for (const [key, value] of data.entries()) {
    convert.append(key, value);
  }
  const output = parseFormData(convert, schemaData);
  output.posted = false;
  return output;
}
function validateResult(parsed, schemaData, result) {
  const { opts: options, entityInfo } = schemaData;
  const posted = parsed.posted;
  const id = parsed.data ? options.id ?? parsed.id ?? entityInfo.hash : options.id ?? entityInfo.hash;
  if (!parsed.data) {
    let data = void 0;
    let errors = {};
    const valid = (result == null ? void 0 : result.success) ?? false;
    const { opts: options2, entityInfo: entityInfo2 } = schemaData;
    if (result) {
      if (result.success) {
        data = result.data;
      } else if (options2.errors === true) {
        errors = mapErrors(result.error.format(), entityInfo2.errorShape);
      }
    }
    return {
      id,
      valid,
      posted,
      errors,
      // Copy the default entity so it's not modified
      data: data ?? clone(entityInfo2.defaultEntity),
      constraints: entityInfo2.constraints
    };
  } else {
    const { opts: options2, schemaKeys, entityInfo: entityInfo2, unwrappedSchema } = schemaData;
    if (!result) {
      throw new SuperFormError("Validation data exists without validation result.");
    }
    if (!result.success) {
      const partialData = parsed.data;
      const errors = options2.errors !== false ? mapErrors(result.error.format(), entityInfo2.errorShape) : {};
      const zodKeyStatus = unwrappedSchema._def.unknownKeys;
      const data = zodKeyStatus == "passthrough" ? { ...clone(entityInfo2.defaultEntity), ...partialData } : Object.fromEntries(schemaKeys.map((key) => [
        key,
        key in partialData ? partialData[key] : clone(entityInfo2.defaultEntity[key])
      ]));
      return {
        id,
        valid: false,
        posted,
        errors,
        data,
        constraints: entityInfo2.constraints
      };
    } else {
      return {
        id,
        valid: true,
        posted,
        errors: {},
        data: result.data,
        constraints: entityInfo2.constraints
      };
    }
  }
}
function getSchemaData(schema, options) {
  const originalSchema = schema;
  let unwrappedSchema = schema;
  let hasEffects = false;
  while (unwrappedSchema._def.typeName == "ZodEffects") {
    hasEffects = true;
    unwrappedSchema = unwrappedSchema._def.schema;
  }
  if (!(unwrappedSchema._def.typeName == "ZodObject")) {
    throw new SuperFormError("Only Zod schema objects can be used with superValidate. Define the schema with z.object({ ... }) and optionally refine/superRefine/transform at the end.");
  }
  const entityInfo = entityData(unwrappedSchema, options == null ? void 0 : options.warnings);
  return {
    originalSchema,
    unwrappedSchema,
    hasEffects,
    entityInfo,
    schemaKeys: entityInfo.keys,
    opts: options ?? {}
  };
}
async function superValidate(data, schema, options) {
  if (data && typeof data === "object" && "safeParseAsync" in data) {
    options = schema;
    schema = data;
    data = null;
  }
  const schemaData = getSchemaData(schema, options);
  async function tryParseFormData(request) {
    let formData = void 0;
    try {
      formData = await request.formData();
    } catch (e) {
      if (e instanceof TypeError && e.message.includes("already been consumed")) {
        throw e;
      }
      return { id: void 0, data: void 0, posted: false };
    }
    return parseFormData(formData, schemaData);
  }
  async function parseRequest() {
    let parsed2;
    if (data instanceof FormData) {
      parsed2 = parseFormData(data, schemaData);
    } else if (data instanceof URL || data instanceof URLSearchParams) {
      parsed2 = parseSearchParams(data, schemaData);
    } else if (data instanceof Request) {
      parsed2 = await tryParseFormData(data);
    } else if (data && typeof data === "object" && "request" in data && data.request instanceof Request) {
      parsed2 = await tryParseFormData(data.request);
    } else {
      parsed2 = {
        id: void 0,
        data,
        posted: false
      };
    }
    const toValidate = dataToValidate(parsed2, schemaData);
    const result2 = toValidate ? await schemaData.originalSchema.safeParseAsync(toValidate) : void 0;
    return { parsed: parsed2, result: result2 };
  }
  const { parsed, result } = await parseRequest();
  return validateResult(parsed, schemaData, result);
}
function superValidateSync(data, schema, options) {
  if (data && typeof data === "object" && "safeParse" in data) {
    options = schema;
    schema = data;
    data = null;
  }
  const schemaData = getSchemaData(schema, options);
  const parsed = data instanceof FormData ? parseFormData(data, schemaData) : data instanceof URL || data instanceof URLSearchParams ? parseSearchParams(data, schemaData) : {
    id: void 0,
    data,
    posted: false
  };
  const toValidate = dataToValidate(parsed, schemaData);
  const result = toValidate ? schemaData.originalSchema.safeParse(toValidate) : void 0;
  return validateResult(parsed, schemaData, result);
}
function actionResult(type, data, options) {
  const status = options && typeof options !== "number" ? options.status : options;
  const result = (struct) => {
    return json({ type, ...struct }, {
      status: struct.status,
      headers: typeof options === "object" && options.message ? {
        "Set-Cookie": `flash=${encodeURIComponent(JSON.stringify(options.message))}; Path=/; Max-Age=120`
      } : void 0
    });
  };
  if (type == "error") {
    return result({
      status: status || 500,
      error: typeof data === "string" ? { message: data } : data
    });
  } else if (type == "redirect") {
    return result({
      status: status || 303,
      location: data
    });
  } else if (type == "failure") {
    return result({
      status: status || 400,
      data: stringify(data)
    });
  } else {
    return result({ status: status || 200, data: stringify(data) });
  }
}

// node_modules/.pnpm/sveltekit-superforms@1.5.0_@sveltejs+kit@1.22.4_svelte@4.1.2_vite@4.4.8_@types+node@18.17.1___svelte@4.1.2_zod@3.21.4/node_modules/sveltekit-superforms/dist/client/index.js
var defaultFormOptions = {
  applyAction: true,
  invalidateAll: true,
  resetForm: false,
  autoFocusOnError: "detect",
  scrollToError: "smooth",
  errorSelector: '[aria-invalid="true"],[data-invalid]',
  selectErrorText: false,
  stickyNavbar: void 0,
  taintedMessage: "Do you want to leave this page? Changes you made may not be saved.",
  onSubmit: void 0,
  onResult: void 0,
  onUpdate: void 0,
  onUpdated: void 0,
  onError: (event) => {
    console.warn("Unhandled Superform error, use onError event to handle it:", event.result.error);
  },
  dataType: "form",
  validators: void 0,
  defaultValidator: "keep",
  customValidity: false,
  clearOnSubmit: "errors-and-message",
  delayMs: 500,
  timeoutMs: 8e3,
  multipleSubmits: "prevent",
  validation: void 0,
  SPA: void 0,
  validateMethod: "auto"
};
var formIds = /* @__PURE__ */ new WeakMap();
function multipleFormIdError(id) {
  return `Duplicate form id's found: "${id}". Multiple forms will receive the same data. Use the id option to differentiate between them, or if this is intended, set the warnings.duplicateId option to false in superForm to disable this warning. More information: https://superforms.rocks/concepts/multiple-forms`;
}
function superForm(form, options = {}) {
  var _a, _b;
  {
    options = {
      ...defaultFormOptions,
      ...options
    };
    if (options.SPA && options.validators === void 0) {
      console.warn("No validators set for superForm in SPA mode. Add them to the validators option, or set it to false to disable this warning.");
    }
  }
  let _formId = options.id;
  if (!form || Context_isValidationObject(form) === false) {
    if (((_a = options.warnings) == null ? void 0 : _a.noValidationAndConstraints) !== false) {
      console.warn((form ? "Form data sent directly to superForm instead of through superValidate. No initial data validation is made. " : "No form data sent to superForm, schema type safety cannot be guaranteed. ") + "Also, no constraints will exist for the form. Set the warnings.noValidationAndConstraints option to false to disable this warning.");
    }
    form = {
      valid: false,
      posted: false,
      errors: {},
      data: form ?? {},
      constraints: {}
    };
  } else {
    if (_formId === void 0)
      _formId = form.id;
  }
  const _initialFormId = _formId;
  const _currentPage = get_store_value(page2);
  if (((_b = options.warnings) == null ? void 0 : _b.duplicateId) !== false) {
    if (!formIds.has(_currentPage)) {
      formIds.set(_currentPage, /* @__PURE__ */ new Set([_initialFormId]));
    } else {
      const currentForms = formIds.get(_currentPage);
      if (currentForms == null ? void 0 : currentForms.has(_initialFormId)) {
        console.warn(multipleFormIdError(_initialFormId));
      } else {
        currentForms == null ? void 0 : currentForms.add(_initialFormId);
      }
    }
  }
  const postedData = _currentPage.form;
  if (postedData && typeof postedData === "object") {
    for (const postedForm of Context_findValidationForms(postedData).reverse()) {
      if (postedForm.id === _formId) {
        const pageDataForm = form;
        form = postedForm;
        if (form.valid && options.resetForm && (options.resetForm === true || options.resetForm())) {
          form = clone(pageDataForm);
          form.message = postedForm.message;
        }
        break;
      }
    }
  }
  const form2 = form;
  const initialForm = clone(form2);
  if (typeof initialForm.valid !== "boolean") {
    throw new SuperFormError("A non-validation object was passed to superForm. Check what's passed to its first parameter.");
  }
  const _errors = writable(form2.errors);
  const FormId = writable(_formId);
  const Context = {
    taintedMessage: options.taintedMessage,
    taintedFormState: clone(initialForm.data)
  };
  function Context_randomId(length = 8) {
    return Math.random().toString(36).substring(2, length + 2);
  }
  function Context_setTaintedFormState(data) {
    Context.taintedFormState = clone(data);
  }
  function Context_findValidationForms(data) {
    const forms = Object.values(data).filter((v) => Context_isValidationObject(v) !== false);
    return forms;
  }
  function Context_isValidationObject(object) {
    if (!object || typeof object !== "object")
      return false;
    if (!("valid" in object && "errors" in object && typeof object.valid === "boolean")) {
      return false;
    }
    return "id" in object && typeof object.id === "string" ? object.id : void 0;
  }
  function Context_useEnhanceEnabled() {
    options.taintedMessage = Context.taintedMessage;
    if (_formId === void 0)
      FormId.set(Context_randomId());
  }
  function Context_newFormStore(data) {
    const _formData = writable(data);
    return {
      subscribe: _formData.subscribe,
      set: (value, options2 = {}) => {
        Tainted_update(value, Context.taintedFormState, options2.taint ?? true);
        Context_setTaintedFormState(value);
        return _formData.set(clone(value));
      },
      update: (updater, options2 = {}) => {
        return _formData.update((value) => {
          const output = updater(value);
          Tainted_update(output, Context.taintedFormState, options2.taint ?? true);
          Context_setTaintedFormState(output);
          return output;
        });
      }
    };
  }
  const Unsubscriptions = [
    FormId.subscribe((id) => _formId = id)
  ];
  function Unsubscriptions_add(func) {
    Unsubscriptions.push(func);
  }
  function Unsubscriptions_unsubscribe() {
    Unsubscriptions.forEach((unsub) => unsub());
  }
  const Form2 = Context_newFormStore(form2.data);
  function Form_checkForNestedData(key, value) {
    if (!value || typeof value !== "object")
      return;
    if (Array.isArray(value)) {
      if (value.length > 0)
        Form_checkForNestedData(key, value[0]);
    } else if (!(value instanceof Date)) {
      throw new SuperFormError(`Object found in form field "${key}". Set the dataType option to "json" and add use:enhance to use nested data structures. More information: https://superforms.rocks/concepts/nested-data`);
    }
  }
  async function Form_updateFromValidation(form3, untaint) {
    if (form3.valid && untaint && options.resetForm && (options.resetForm === true || options.resetForm())) {
      Form_reset(form3.message);
    } else {
      rebind(form3, untaint);
    }
    if (formEvents.onUpdated.length) {
      await tick();
    }
    for (const event of formEvents.onUpdated) {
      event({ form: form3 });
    }
  }
  function Form_reset(message2, data, id) {
    const resetData = clone(initialForm);
    resetData.data = { ...resetData.data, ...data };
    if (id !== void 0)
      resetData.id = id;
    rebind(resetData, true, message2);
  }
  const Form_updateFromActionResult = async (result, untaint) => {
    if (result.type == "error") {
      throw new SuperFormError(`ActionResult of type "${result.type}" cannot be passed to update function.`);
    }
    if (result.type == "redirect") {
      if (options.resetForm && (options.resetForm === true || options.resetForm())) {
        Form_reset();
      }
      return;
    }
    if (typeof result.data !== "object") {
      throw new SuperFormError("Non-object validation data returned from ActionResult.");
    }
    const forms = Context_findValidationForms(result.data);
    if (!forms.length) {
      throw new SuperFormError("No form data returned from ActionResult. Make sure you return { form } in the form actions.");
    }
    for (const newForm of forms) {
      if (newForm.id !== _formId)
        continue;
      await Form_updateFromValidation(newForm, untaint ?? (result.status >= 200 && result.status < 300));
    }
  };
  const LastChanges = writable([]);
  const Message = writable(form2.message);
  const Constraints = writable(form2.constraints);
  const Posted = writable(false);
  const Errors = {
    subscribe: _errors.subscribe,
    set: _errors.set,
    update: _errors.update,
    /**
     * To work with client-side validation, errors cannot be deleted but must
     * be set to undefined, to know where they existed before (tainted+error check in oninput)
     */
    clear: () => clearErrors(_errors, {
      undefinePath: null,
      clearFormLevelErrors: true
    })
  };
  const Tainted = writable();
  function Tainted_data() {
    return get_store_value(Tainted);
  }
  function Tainted_isTainted(obj) {
    if (obj === null)
      throw new SuperFormError("$tainted store contained null");
    if (typeof obj === "object") {
      for (const obj2 of Object.values(obj)) {
        if (Tainted_isTainted(obj2))
          return true;
      }
    }
    return obj === true;
  }
  async function Tainted__validate(path, taint) {
    if (options.validationMethod == "onblur" || options.validationMethod == "submit-only") {
      return false;
    }
    let shouldValidate = options.validationMethod === "oninput";
    if (!shouldValidate) {
      const errorContent = get_store_value(Errors);
      const errorNode = errorContent ? pathExists(errorContent, path, {
        modifier: (pathData) => {
          if (isInvalidPath(path, pathData)) {
            throw new SuperFormError("Errors can only be added to form fields, not to arrays or objects in the schema. Path: " + pathData.path.slice(0, -1));
          }
          return pathData.value;
        }
      }) : void 0;
      const hasError = errorNode && errorNode.key in errorNode.parent;
      shouldValidate = !!hasError;
    }
    if (shouldValidate) {
      await validateField(path, options, Form2, Errors, Tainted, { taint });
      return true;
    } else {
      return false;
    }
  }
  async function Tainted_update(newObj, compareAgainst, taintOptions) {
    if (taintOptions === false) {
      return;
    } else if (taintOptions === "untaint-all") {
      Tainted.set(void 0);
      return;
    }
    let paths = comparePaths(newObj, compareAgainst);
    if (typeof taintOptions === "object") {
      if (typeof taintOptions.fields === "string")
        taintOptions.fields = [taintOptions.fields];
      paths = taintOptions.fields.map((path) => splitPath(path));
      taintOptions = true;
    }
    if (taintOptions === true) {
      LastChanges.set(paths);
    }
    if (paths.length) {
      Tainted.update((tainted) => {
        if (!tainted)
          tainted = {};
        setPaths(tainted, paths, taintOptions === true ? true : void 0);
        return tainted;
      });
      let updated = false;
      for (const path of paths) {
        updated = updated || await Tainted__validate(path, taintOptions);
      }
      if (!updated)
        await validateObjectErrors(options, get_store_value(Form2), Errors);
    }
  }
  function Tainted_set(tainted, newData) {
    Tainted.set(tainted);
    Context_setTaintedFormState(newData);
  }
  const Submitting = writable(false);
  const Delayed = writable(false);
  const Timeout = writable(false);
  const AllErrors = derived(Errors, ($errors) => {
    if (!$errors)
      return [];
    return flattenErrors($errors);
  });
  options.taintedMessage = void 0;
  onDestroy(() => {
    var _a2;
    Unsubscriptions_unsubscribe();
    for (const events of Object.values(formEvents)) {
      events.length = 0;
    }
    (_a2 = formIds.get(_currentPage)) == null ? void 0 : _a2.delete(_initialFormId);
  });
  if (options.dataType !== "json") {
    for (const [key, value] of Object.entries(form2.data)) {
      Form_checkForNestedData(key, value);
    }
  }
  function rebind(form3, untaint, message2) {
    if (untaint) {
      Tainted_set(typeof untaint === "boolean" ? void 0 : untaint, form3.data);
    }
    message2 = message2 ?? form3.message;
    Form2.set(form3.data, { taint: false });
    Message.set(message2);
    Errors.set(form3.errors);
    FormId.set(form3.id);
    Posted.set(form3.posted);
    if (options.flashMessage && shouldSyncFlash(options)) {
      const flash = options.flashMessage.module.getFlash(page2);
      if (message2 && get_store_value(flash) === void 0) {
        flash.set(message2);
      }
    }
  }
  const formEvents = {
    onSubmit: options.onSubmit ? [options.onSubmit] : [],
    onResult: options.onResult ? [options.onResult] : [],
    onUpdate: options.onUpdate ? [options.onUpdate] : [],
    onUpdated: options.onUpdated ? [options.onUpdated] : [],
    onError: options.onError ? [options.onError] : []
  };
  if (browser2) {
    beforeNavigate((nav) => {
      if (options.taintedMessage && !get_store_value(Submitting)) {
        const taintStatus = Tainted_data();
        if (taintStatus && Tainted_isTainted(taintStatus) && !window.confirm(options.taintedMessage)) {
          nav.cancel();
        }
      }
    });
    Unsubscriptions_add(page2.subscribe(async (pageUpdate) => {
      if (!options.applyAction)
        return;
      const untaint = pageUpdate.status >= 200 && pageUpdate.status < 300;
      if (pageUpdate.form && typeof pageUpdate.form === "object") {
        if (pageUpdate.form.type == "error")
          return;
        const forms = Context_findValidationForms(pageUpdate.form);
        for (const newForm of forms) {
          if (newForm.id !== _formId)
            continue;
          await Form_updateFromValidation(newForm, untaint);
        }
      } else if (pageUpdate.data && typeof pageUpdate.data === "object") {
        const forms = Context_findValidationForms(pageUpdate.data);
        for (const newForm of forms) {
          if (newForm.id !== _formId)
            continue;
          rebind(newForm, untaint);
        }
      }
    }));
  }
  const Fields = Object.fromEntries(Object.keys(initialForm.data).map((key) => {
    return [
      key,
      {
        name: key,
        value: fieldProxy(Form2, key),
        errors: fieldProxy(Errors, key),
        constraints: fieldProxy(Constraints, key)
      }
    ];
  }));
  function validate(path, opts) {
    if (path === void 0) {
      return clientValidation(options, get_store_value(Form2), _formId, get_store_value(Constraints), false);
    }
    return validateField(splitPath(path), options, Form2, Errors, Tainted, opts);
  }
  return {
    form: Form2,
    formId: FormId,
    errors: Errors,
    message: Message,
    constraints: Constraints,
    fields: Fields,
    tainted: Tainted,
    submitting: derived(Submitting, ($s) => $s),
    delayed: derived(Delayed, ($d) => $d),
    timeout: derived(Timeout, ($t) => $t),
    options,
    capture: function() {
      return {
        valid: initialForm.valid,
        posted: get_store_value(Posted),
        errors: get_store_value(Errors),
        data: get_store_value(Form2),
        constraints: get_store_value(Constraints),
        message: get_store_value(Message),
        id: _formId,
        tainted: get_store_value(Tainted)
      };
    },
    restore: function(snapshot) {
      return rebind(snapshot, snapshot.tainted ?? true);
    },
    validate,
    enhance: (el, events) => {
      if (events) {
        if (events.onError) {
          if (options.onError === "apply") {
            throw new SuperFormError('options.onError is set to "apply", cannot add any onError events.');
          } else if (events.onError === "apply") {
            throw new SuperFormError('Cannot add "apply" as onError event in use:enhance.');
          }
          formEvents.onError.push(events.onError);
        }
        if (events.onResult)
          formEvents.onResult.push(events.onResult);
        if (events.onSubmit)
          formEvents.onSubmit.push(events.onSubmit);
        if (events.onUpdate)
          formEvents.onUpdate.push(events.onUpdate);
        if (events.onUpdated)
          formEvents.onUpdated.push(events.onUpdated);
      }
      return formEnhance(el, Submitting, Delayed, Timeout, Errors, Form_updateFromActionResult, options, Form2, Message, Context_useEnhanceEnabled, formEvents, FormId, Constraints, Tainted, LastChanges, Context_findValidationForms, Posted);
    },
    allErrors: AllErrors,
    posted: Posted,
    reset: (options2) => Form_reset((options2 == null ? void 0 : options2.keepMessage) ? get_store_value(Message) : void 0, options2 == null ? void 0 : options2.data, options2 == null ? void 0 : options2.id)
  };
}
export {
  actionResult,
  booleanProxy,
  dateProxy,
  defaultValues,
  fieldProxy,
  formFieldProxy,
  intProxy,
  message,
  numberProxy,
  setError,
  setMessage,
  stringProxy,
  superForm,
  superValidate,
  superValidateSync
};
//# sourceMappingURL=sveltekit-superforms_client.js.map
